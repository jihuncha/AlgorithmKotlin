## Kotlin Flow Study

### Kotlin Coroutine and Flow

* https://dalinaum.github.io/coroutines-example/

#### Chap01 처음 만나는 코루틴

1. **예제 1: 간단한 코루틴** <br>
   아주 간단한 코루틴을 수행해봅시다. 코루틴을 만드는 가장 간단한 함수는 runBlocking이라고 합니다. 이렇게 코루틴을 만드는 함수를 코루틴 빌더라고 합니다. runBlocking은 코루틴을 만들고 코드
   블록이 수행이 끝날 때까지 runBlocking 다음의 코드를 수행하지 못하게 막습니다. 그래서 블로킹(blocking)인거죠. <br>

2. **예제 2: 코루틴 빌더의 수신 객체** <br>
   runBlocking안에서 this를 수행하면 코루틴이 수신 객체(Receiver)인 것을 알 수 있습니다.
   "coroutine#1":BlockingCoroutine{Active}@3930015a 이런 형태의 결과가 나옵니다. BlockingCoroutine은 CoroutineScope의 자식입니다. 코틀린 코루틴을
   쓰는 모든 곳에는 코루틴 스코프(CoroutineScope)가 있다고 생각하면 됩니다. 코루틴의 시작은 코루틴 스코프다. 외웁시다. <br>

3. **예제 3: 코루틴 컨텍스트** <br>
   코루틴 스코프는 코루틴을 제대로 처리하기 위한 정보, 코루틴 컨텍스트(CoroutineContext)를 가지고 있습니다. 수신 객체의 coroutineContext를 호출해 내용을 확인해봅시다. <br>

4. **예제 4: launch 코루틴 빌더** <br>
   이제 코루틴 내에서 다른 코루틴을 수행해 봅시다. 이번에는 launch란 빌더를 사용해서 코드를 수행합니다. launch는 코루틴 빌더입니다. 새로운 코루틴을 만들기 때문에 새로운 코루틴 스코프를 만들게
   되고요. launch는 “할 수 있다면 다른 코루틴 코드를 같이 수행”시키는 코루틴 빌더입니다. <br>
launch 코루틴 빌더에 있는 내용이 runBlocking이 있는 메인 흐름 보다 늦게 수행된 것을 볼 수 있습니다. 둘 다 메인 스레드(main)를 사용하기 때문에 runBlocking의 코드들이 메인 스레드를
다 사용할 때 까지 launch의 코드 블록이 기다리는 것입니다. runBlocking은 Hello를 출력하고 나서 종료하지는 않고 launch 코드블록의 내용이 다 끝날 때까지 기다립니다. <br>

5. **예제 5: delay 함수** <br>
   Hello를 조금 더 늦게 수행시키기 위해서는 delay 함수를 호출해 봅시다. 인자로 밀리세컨드 단위의 시간을 지정할 수 있습니다. <br>

6. **예제 6: 코루틴 내에서 sleep** <br>
   우리가 잘 아는 Thread.sleep을 호출하면 어떻게 될까요? 우리가 원하는 결과가 나오지 않았을 것입니다. Thread.sleep을 하면 코루틴이 아무 일을 하지 않는 동안에도 스레드를 양보하지 않고
   독점합니다. <br>

7. **예제 7: 한번에 여러 launch** <br>
   1, 2, 3을 순서대로 수행시켜봅시다. 딜레이 값을 바꿔 보면 suspend된 이후 깨어나는 순서에 따라 출력 결과가 달라집니다. <br>

8. **예제 8: 상위 코루틴은 하위 코루틴을 끝까지 책임진다.** <br>
   runBlocking 안에 두 launch가 속해 있는데 계층화되어 있어 구조적입니다. runBlocking은 그 속에 포함된 launch가 다 끝나기 전까지 종료되지 않습니다.<br>

9. **예제 9: suspend 함수** <br>
   delay, launch 등 지금까지 봤던 함수들은 코루틴 내에서만 호출 할 수 있습니다. 
그럼 이 함수들을 포함한 코드들을 어떻게 함수로 분리할 수 있을까요? 
코드의 일부를 함수로 분리할 때는 함수의 앞에 suspend 키워드를 붙이면 됩니다. 
doOne은 delay와 같은 함수(suspend인 함수)를 호출하지 않았기 때문에 suspend를 붙이지 않은 일반 함수로 해도 됩니다.
만약 suspend 함수를 다른 함수에서 호출하려면 그 함수가 suspend 함수이거나 코루틴 빌더를 통해 코루틴을 만들어야 합니다. <br>

#### Chap02 스코프빌더와 잡

10. **예제 10: suspend 함수에서 코루틴 빌더 호출** <br>
    코루틴 빌더를 suspend 함수 안에서 호출하면 어떻게 될까요? - 코루틴 빌더는 코루틴 스코프 내에서만 호출해야 합니다. <br>

11. **예제 11: 코루틴 스코프** <br>
    코루틴 스코프를 만드는 다른 방법은 스코프 빌더를 이용하는 것입니다. coroutineScope를 이용해보세요.
코루틴 스코프는 runBlocking을 썼을 때와 모양이 거의 비슷합니다.
하지만 둘의 차이가 있는데 **runBlocking은 현재 쓰레드를 멈추게 만들고, 기다리지만 coroutineScope는 현재 스레드를 멈추게 하지 않습니다.** 
호출한 쪽이 suspend되고 시간이 되면 다시 활동하게 됩니다. <br>

12. **예제 12: Job을 이용한 제어** <br>
    코루틴 빌더 launch는 Job객체를 반환하며 이를 통해 종료될 때까지 기다릴 수 있습니다. <br>

13. **예제 13: 가벼운 코루틴** <br>
    코루틴은 협력적으로 동작하기 때문에 여러 코루틴을 만드는 것이 큰 비용이 들지 않습니다. 
10만개의 간단한 일을 하는 코루틴도 큰 부담은 아닙니다.
(하지만 코틀린 플레이그라운드의 한계로 그렇게 많은 코루틴은 로그를 찍지 못합니다.) <br>

#### 취소와 타임아웃

14. **예제 14: Job에 대해 취소** <br>
    명시적인 Job에 대해 cancel 메서드를 호출해 취소할 수 있습니다, delay 간격들을 변경해 보면서 테스트 해보세요. <br>

15. **예제 15: 취소 불가능한 Job** <br>
    예제는 취소가 불가능한 Job입니다.
launch(Dispatchers.Default)는 그 다음 코드 블록을 다른 스레드에서 수행을 시킬 것입니다.
두가지 부분이 신경이 쓰입니다.
* job1이 취소든 종료든 다 끝난 이후에 doCount Done!을 출력하고 싶다.
* 취소가 되지 않았다.
먼저 취소든 종료든 다 끝난 이후에 doCount Done!을 출력합시다. <br>

16. **예제 16: cancel과 join** <br>
    cancel 이후에 join을 넣어서 실제로 doCount가 끝날 때 doCount Done!가 출력하게 했습니다. <br>

17. **예제 17: cancelAndJoin** <br>
    cancel을 하고 join을 하는 일은 자주 일어나는 일이기 때문에 한번에 하는 cancelAndJoin이 준비되어 있습니다.
18. ㅇ
19. ㅇ
20. ㅇ
21. ㅇ
22. 